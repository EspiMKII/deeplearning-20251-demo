{% extends "base.html" %}

{% block title %}Input something...{% endblock %}
{% block demo %}Input{% endblock %}

{% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='user_input.css') }}">
{% endblock %}

{% block content %}
    <form id="modeForm" method="post">
        <button id="modeBg" type="button">
          <label id="modeChoiceLabel" for="modeChoice">Select how to run the model:</label>
          <br>
          <select id="modeChoice" required>
              <option value="none">--choose--</option>
              <option value="inpainting">Inpainting</option>
              <option value="seg">Segmentation</option>
          </select>
        </button>
    </form>

    <!-- hidden until selected -->
    <div id="modeInpainting" hidden>
        <div class="inpaintingText">
          <p class="inpaintingText">Pick the coordinates for the mask:</p>
        </div>

        <!-- wrapper so canvas can overlay the image cleanly -->
        <div class="imageWrapper" style="display:inline-block; position:relative;">
            <img id="baseImageInpainting" src="{{url}}" alt="base image"/>
        </div>

        <form id="inpaintingForm" method="post">
            <input type="hidden" name="form_id" value="inpainting">

            <label class="inpaintingText" for="topX">Top-left horizontal coordinate:</label>
            <input name="topX" id="topX" type="number" min="0" step="1" required>
            <br>

            <label class="inpaintingText" for="topY">Top-left vertical coordinate:</label>
            <input name="topY" id="topY" type="number" min="0" step="1" required>
            <br>

            <label class="inpaintingText" for="width">Width:</label>
            <input name="width" id="width" type="number" min="0" step="1" required>
            <br>

            <label class="inpaintingText" for="height">Height:</label>
            <input name="height" id="height" type="number" min="0" step="1" required>
            <br>

            <button type="submit" class="run">Run the model</button>
        </form>


    </div>

    <!-- hidden until selected -->
    <div id="modeSeg" class="modeSeg">

        <div class="segText">
        <p>Use your mouse to draw a highlight over the image.</p>
        </div>

        <div class="imageWrapper" style="display:inline-block; position:relative;">
            <img id="baseImageSeg" src="{{url}}" alt ="base image" />
        </div>

        <form id="segForm" method="post">
            <input type="hidden" name="form_id" value="segmentation">

            <input type="hidden" name="topX" id="topX">
            <input type="hidden" name="topY" id="topY">
            <input type="hidden" name="width" id="width">
            <input type="hidden" name="height" id="height">

            <label id="segModelTypeLabel" for="segModelType">Select segmentation model:</label>
            <br>
            <select id="segModelType" name="segModelType" required>
                <option value="fcn16s">fcn16s</option>
                <option value="unet">unet</option>
            </select>

            <button type="submit" class="run">Run the model</button>
        </form>
    </div>

    {#hides unused operation modes as necessary#}
    <script>
        (function() {
          /* Hides or shows the operation modes as necessary */
          const select = document.getElementById('modeChoice');
          const panelInpaint = document.getElementById('modeInpainting');
          const panelSeg = document.getElementById('modeSeg');

          function updatePanels(value) {
            if (value === 'inpainting') {
              panelInpaint.hidden = false;
              panelInpaint.setAttribute('aria-hidden', 'false');
              panelSeg.hidden = true;
              panelSeg.setAttribute('aria-hidden', 'true');
            } else if (value === 'seg') {
              panelInpaint.hidden = true;
              panelInpaint.setAttribute('aria-hidden', 'true');
              panelSeg.hidden = false;
              panelSeg.setAttribute('aria-hidden', 'false');
            } else { // none selected
              panelInpaint.hidden = true;
              panelInpaint.setAttribute('aria-hidden', 'true');
              panelSeg.hidden = true;
              panelSeg.setAttribute('aria-hidden', 'true');
            }
          }

        if (select) {
          // initialize on page load
          updatePanels(select.value);

          // update on change
          select.addEventListener('change', (e) => updatePanels(e.target.value));
        }

        /* Canvas overlay & Mask drawing for inpainting */
        const img = document.getElementById('baseImageInpainting');
        if (!img) return;

        const wrapper = img.parentElement;
        wrapper.style.position = wrapper.style.position || 'relative';
        const canvas = document.createElement('canvas');
        canvas.id = 'overlayCanvas';
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.pointerEvents = 'none';
        wrapper.appendChild(canvas);

        const inputX = document.getElementById('topX');
        const inputY = document.getElementById('topY');
        const inputW = document.getElementById('width');
        const inputH = document.getElementById('height');

        function resizeCanvasToImage() {
          const displayW = img.clientWidth;
          const displayH = img.clientHeight;

          canvas.width = displayW;
          canvas.height = displayH;
          canvas.style.width = displayW + 'px';
          canvas.style.height = displayH + 'px';

          // Calculate image's actual position within the wrapper
          const wrapperRect = wrapper.getBoundingClientRect();
          const imgRect = img.getBoundingClientRect();

          canvas.style.left = (imgRect.left - wrapperRect.left) + 'px';
          canvas.style.top = (imgRect.top - wrapperRect.top) + 'px';

          drawMask();
        }

        function drawMask() {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const x = Number(inputX.value);
          const y = Number(inputY.value);
          const w = Number(inputW.value);
          const h = Number(inputH.value);
          if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) {
            return;
          }

          const xi = Math.max(0, Math.floor(x));
          const yi = Math.max(0, Math.floor(y));
          let wi = Math.max(0, Math.floor(w));
          let hi = Math.max(0, Math.floor(h));
          // clamp to canvas bounds
          if (xi >= canvas.width || yi >= canvas.height) return; // fully outside
          if (xi + wi > canvas.width) wi = canvas.width - xi;
          if (yi + hi > canvas.height) hi = canvas.height - yi;
          if (wi <= 0 || hi <= 0) return;

          ctx.fillStyle = 'rgba(0, 0, 0, 1)';
          ctx.fillRect(xi, yi, wi, hi);
        }

        // Initialize when image loads (and if already loaded)
        function init() {
          resizeCanvasToImage();

          // redraw when user types
          [inputX, inputY, inputW, inputH].forEach(el => {
            if (!el) return;
            el.addEventListener('input', () => {
              if (el.value === '') return drawMask();
              const n = Math.floor(Number(el.value));
              if (!Number.isFinite(n)) return;
              // don't overwrite while user types â€” only clamp visually here
              drawMask();
            });
          });

          // keep canvas aligned on window resize
          window.addEventListener('resize', resizeCanvasToImage);
        }

        if (img.complete && img.naturalWidth !== 0) { // image already loaded
          init();
        } else {
          img.addEventListener('load', init);
        }


        /* Canvas overlay & Object selection for segmentation */
        const imgSeg = document.getElementById('baseImageSeg');
        if (!imgSeg) return;

        const wrapperSeg = imgSeg.parentElement;
        wrapperSeg.style.position = wrapperSeg.style.position || 'relative';
        const canvasSeg = document.createElement('canvas');
        canvasSeg.id = 'overlayCanvasSeg';
        canvasSeg.style.position = 'absolute';
        canvasSeg.style.left = '0';
        canvasSeg.style.top = '0';
        canvasSeg.style.cursor = 'crosshair';
        wrapperSeg.appendChild(canvasSeg);

        const segForm = document.getElementById('segForm');
        const inputXSeg = segForm.querySelector('#topX');
        const inputYSeg = segForm.querySelector('#topY');
        const inputWSeg = segForm.querySelector('#width');
        const inputHSeg = segForm.querySelector('#height');

        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;

        function resizeCanvasToImageSeg() {
          const displayW = imgSeg.clientWidth;
          const displayH = imgSeg.clientHeight;

          canvasSeg.width = displayW;
          canvasSeg.height = displayH;
          canvasSeg.style.width = displayW + 'px';
          canvasSeg.style.height = displayH + 'px';

          // Calculate image's actual position within the wrapper
          const wrapperRect = wrapperSeg.getBoundingClientRect();
          const imgRect = imgSeg.getBoundingClientRect();

          canvasSeg.style.left = (imgRect.left - wrapperRect.left) + 'px';
          canvasSeg.style.top = (imgRect.top - wrapperRect.top) + 'px';

          drawHighlight();
        }

        function drawHighlight() {
          const ctx = canvasSeg.getContext('2d');
          ctx.clearRect(0, 0, canvasSeg.width, canvasSeg.height);

          if (!isDrawing && (startX === 0 && startY === 0 && currentX === 0 && currentY === 0)) {
            return;
          }

          const rectX = Math.min(startX, currentX);
          const rectY = Math.min(startY, currentY);
          const rectW = Math.abs(currentX - startX);
          const rectH = Math.abs(currentY - startY);

          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.fillRect(rectX, rectY, rectW, rectH);

          ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
          ctx.lineWidth = 2;
          ctx.strokeRect(rectX, rectY, rectW, rectH);

          if (inputXSeg && inputYSeg && inputWSeg && inputHSeg) {
            inputXSeg.value = Math.floor(rectX);
            inputYSeg.value = Math.floor(rectY);
            inputWSeg.value = Math.floor(rectW);
            inputHSeg.value = Math.floor(rectH);
          }
        }

        function getMousePos(e) {
          const rect = canvasSeg.getBoundingClientRect();
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
          };
        }

        // Mouse event handlers
        function handleMouseDown(e) {
          if (e.button !== 0) return; // only left click

          const pos = getMousePos(e);
          startX = Math.max(0, Math.min(pos.x, canvasSeg.width));
          startY = Math.max(0, Math.min(pos.y, canvasSeg.height));
          currentX = startX;
          currentY = startY;
          isDrawing = true;

          // Clear previous highlight
          const ctx = canvasSeg.getContext('2d');
          ctx.clearRect(0, 0, canvasSeg.width, canvasSeg.height);

          e.preventDefault();
        }

        function handleMouseMove(e) {
          if (!isDrawing) return;

          const pos = getMousePos(e);
          currentX = Math.max(0, Math.min(pos.x, canvasSeg.width));
          currentY = Math.max(0, Math.min(pos.y, canvasSeg.height));

          drawHighlight();
          e.preventDefault();
        }

        function handleMouseUp(e) {
          if (e.button !== 0 || !isDrawing) return;

          isDrawing = false;
          drawHighlight();
          e.preventDefault();
        }

        function initSeg() {
          resizeCanvasToImageSeg();

          canvasSeg.addEventListener('mousedown', handleMouseDown);
          canvasSeg.addEventListener('mousemove', handleMouseMove);
          canvasSeg.addEventListener('mouseup', handleMouseUp);

          canvasSeg.addEventListener('contextmenu', e => e.preventDefault());

          // Keep canvas aligned on window resize
          window.addEventListener('resize', resizeCanvasToImageSeg);
        }

        if (imgSeg.complete && imgSeg.naturalWidth !== 0) {
          initSeg();
        } else {
          imgSeg.addEventListener('load', initSeg);
        }

        })();
    </script>

{% endblock %}
